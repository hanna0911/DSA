### 1-1 A+B problem

1. **数据结构与算法**：高精度计算——压位

   1. **构思**：

      对于 `10 ^ 5000` 量级的数字，直接进行乘法运算显然是不行的；将乘数利用竖式乘法运算，也有 `5000` 位数字，若仍以`10` 进制进行运算，对于 `500` 个测例，极端情况将进行 `5000 ^ 2 * 500 = 12500000000` 次运算，显然会时间超限。

      因此想到利用 `long long` 类型可以存储的最大数为 `2 ^ 63 - 1 ≈ 10 ^ 18.96` ，即对于 `2` 个 `9` 位数的十进制数进行 `1` 次乘法以及 `1` 次加法，其必然仍在 `long long` 的取值范围之内（ `999999999 ^ 2 * 2 ≈ 1.999999996 * 10 ^ 18 < 10 ^ 18.96` ）；又因为乘法、加法计算对不同进制，其本质计算方法与原理均是相同的（进位等），所以会想到将 `10` 进制拓展到 `10 ^ 10` 进制来进行计算。

   2. **原理**：乘法原理，加法原理（竖式乘法），`X` 进制计算（此题实现中 `X = 10 ^ 10` ）。

   3. **实现要点**：

      1. **输入**：以字符串 `char []` 类型输入乘数。
      2. **高精度数拆分**：在 `convertion()` 函数中具体实现，从末位至首位每 `9` 位一断，利用 `cstirng` 库中的 `strncpy()` 函数取出长度为 `9` 的字符串，并用 `char_to_int()` 函数将该字符串转为 `long long` 类型的数值。
      3. **竖式乘法**：外层循环将第二个乘数由末位开始遍历整个乘数的各个数位，与第一个乘数进行乘法，在 `mutiply()` 函数中的内层循环将第一个乘数由末位开始遍历整个乘数的各个数位，乘法和累加同步进行。注意若该次乘法与加法计算出的数值 ` ≧ 10 ^ 10` ，则按照每 `10 ^ 10` 位一进位（逢 `10 ^ 10` 进 `1` ）。
      4. **输出**：除首位输出无需补 `0` 外，其他数位输出时，均通过 `printf("%09lld", answer[j])` 输出格式化，对每一不足 `9` 位的输出前几位补 `0` 。

2. **问题**：时间超限

   1. **解决1**：压位位数由 `8` 位更新到 `9` 位

      优化前后乘法运算的时间复杂度虽均为 `O(loga * logb)` ，但对时间复杂度有常数量级的优化，优化前极端情况运算次数达`500 * (5000 / 8) ^ 2 ≈ 200000000` 次，优化后约为 `500 * (5000 / 8) ^ 2 ≈ 150000000` 次，效率提高约 `1.4` 倍。

   2. **解决2**：对字符串转数值的方法进行优化

      参考资料：https://tombarta.wordpress.com/2008/04/23/specializing-atoi/

      （仅截取部分代码进行优化前后的对比，来说明优化方式）

      ```c++
      for(int i = 0; i < xIntLen; i++){
        	long long sum = 0; // 8位char的long long数值
        	for(int j = 0; j < 9; j++){
            	int pos = aLen - (i * 9) - j - 1; // 在char[]中的位置下标
            	if(pos >= 0) sum += (int(x[pos]) - int('0')) * power(j);
          }
        	xInt[xIntLen - i - 1] = sum;
      }
      ```

      上述代码为优化前字符串转数值的方法，可见遍历了输入序列的每一个元素，因此字符串转数值的部分，对 `1` 个字符串（数值型大小为 `a` ）优化前时间复杂度约为 `O(loga)` ，对于所有测例对 `2` 个乘数均做字符串转数值，时间复杂度约为 `O(n * (loga + logb))` 。

      对于内嵌函数 `power()` ，其通过 `for` 循环来计算 `10` 的幂次：

      ```c++
      long long power(int x){ // 求 10 ^ x 
        	long long product = 1;
        	for(int i = 0; i < x; i++)
          		product *= 10;
        	return product;
      }
      ```

      因此优化前的代码，极端情况的计算次数达 `500 * (5000 + 5000) * 4 = 20000000` 次（ `4` 是常数，是 `power()` 对长度为 `5000` 的字符串进行处理时的均摊时间）。

      需要注意的是，优化后的时间复杂度也是 `O(n * (loga + logb))` ，优化体现在常数量级。

      ```c++
      for(int i = 0; i < xIntLen - 1; i++){
        	strncpy(t, &x[xLen - (i + 1) * 9], 9); // 每9位记为1个long long型数
        	t[9] = '\0';
        	xInt[xIntLen - i - 1] = char_to_int(t);
      }
      ```

      该方法时间复杂度也为 `O(n * (loga + logb))` ，但外层循环的 `O(n)` 实际上循环次数的常数量由 `1` 降为 `1/9` ，幂次的计算也省略了，以内嵌函数 `char_to_int()` 来替代，其不使用循环来计算，而是用 `switch - case` 来实现，均摊时间复杂度的常数量级由 `4` 降为 `1` ：

      ```c++
      long long char_to_int(const char *x){ // 将字符串转为long long
      		int len = strlen(x);
       		long long sum = 0;
         	switch(len){ // 9位数
             	case 10:
                 	sum += (x[len - 10] - '0') * 1000000000;
             	case 9:
                 	sum += (x[len - 9] - '0') * 100000000;
             	... // 此处省略 case 2 - 8
             	case 1:
                 	sum += (x[len- 1] - '0');
         	}
         	return sum;
      }
      ```

      因此优化后极端情况的计算次数约 `500 * (5000 / 9 + 5000 / 9) * 1 ≈ 500000` 次，相比优化前提高了 `40` 倍的效率。

   3. **解决3**：乘法、加法同步运算（ `1` 个 `for` 循环）

      （仅截取部分代码进行优化前后的对比，来说明优化方式）

      ```c++
      // 乘法
      for(int j = bIntLen - 1; j >= 0; j--){
        	... // 省略
          for(int k = aIntLen - 1; k >= 0; k--){
            	long long product = jinwei + aInt[k] * bInt[j];
            	... // 省略
          }
      }
      
      // 加法
      for(int j = 0; j < bIntLen; j++){
        	... // 省略
          while(ansPart[j][k] >= 0){
            	ansFull[t] += jinwei + ansPart[j][k];
            	... // 省略
              k++;
            	t++;
          }
      }
      ```

      如上述代码，优化前乘法、加法分开计算，即先通过 `O(loga * logb)` 的乘法算出 `logb / 9` 个加数，每个加数的“位数”约为 `loga / 9` 位，再进行 `O(loga * logb)` 的加法计算出最终答案 ，一共需要通过 `2` 个 `for` 循环（乘法、加法均为 `2` 层循环）。

      优化前后时间复杂度均为 `O(loga * logb)` ，优化在常数量级。优化后只需 `1` 个 `for` 循环（为 `2` 层循环）：

      ```c++
      for(int j = bIntLen - 1; j >= 0; j--){
        	multiply(aInt, aIntLen, bInt[j], answer, bIntLen - 1 - j);
      }
      ```

      其中内嵌 `multiply()` 函数为：

      ```c++
      void multiply(long long * aInt, int aIntLen, long long num, long long * answer, int base){
        	... // 省略
          for(int i = aIntLen - 1; i >= 0; i--){
          long long sum = answer[pos] + aInt[i] * num + jinwei; // 乘法和加法同时做，减少循环次数
            ... // 省略
          }
        	... // 省略
      }
      ```

      即直接通过 `O(loga * logb)` 的乘法与加法计算出最终答案。

3. **复杂度估算**：

   1. **时间复杂度**： `O(n * loga * logb)` 
   
      因为需要计算 `n` 组乘法，最外层 `for` 循环次数为 `n` ；而对于一组乘法计算，时间复杂度与 `a` , `b` 两数的位数，即 `loga` 和 `logb` 的乘积有关。因此整个完整程序的时间复杂度为 `O(n * loga * logb)` 。
   
   2. **空间复杂度**： `O(loga + logb)` 
   
      对于每一组乘法，都会调用 `convertion()` ，其中 `new` 分配了 `loga` , `logb` 大小的内存空间，于每次乘法结束后释放。因此对于全部 `n` 组乘法，空间复杂度与进行一组乘法的空间复杂度相同，即为 `O(loga + logb)` 。

