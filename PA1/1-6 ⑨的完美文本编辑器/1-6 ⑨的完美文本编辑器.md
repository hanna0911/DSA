### 1-6 ⑨的完美文本编辑器

1. **数据结构与算法**：链表

   1. **构思**：

      观察到功能列表中包含左移、右移、插入、删除、翻转、输出共 `6` 个操作，其中左移、右移、插入、删除、翻转操作对于链表来说都是 `O(1)` 时间可以完成的，而对于其他数据结构均需要多于 `O(1)` 时间（如对 `vector` 而言，插入、删除的最坏情况均为 `O(n)` ，翻转为 `O(n)` ，其中 `n` 为序列长度）；输出所有数据结构最少均需要 `O(n)` ，链表也是 `O(n)` 。

      也就是说链表对此题是最高效的数据结构，因此选择用链表来存储数据。

   2. **原理**：双向链表的数组实现（用数组来存储链表节点）。

   3. **实现要点**：

      1. **输入**：输入初始文本为字符串格式。
      2. **创建链表**：用 `linkedList` 封装好的类（实现了初始化、插入、删除功能，节点存储在全局数组中）的对象 `list1` ,  `list2` 来存储链表，`list1` 顺序插入初始文本中的字符，`list2` 则逆序插入；两个链表均设置首、尾哨兵节点。
      3. **读取指令**： `switch - case` 实现指令读取。
      4. **指令实现**：
         1. **左移**：对每种光标类型，考虑光标顶左头和不顶左头两种情况即可。
         2. **右移**：对每种光标类型，考虑光标顶右头和不顶右头两种情况即可。
         3. **插入**：对每种光标类型，考虑两光标重合和两光标不重合两种情况即可。
         4. **删除**：对每种光标类型，考虑光标重合、待删除点处有光标、和其他情况共三种情况即可。
         5. **翻转**：根据当前光标位置判断是否能翻转，若可以，则通过令两个链表翻转区域交界处互相指向对方来实现 `O(1)` 时间复杂度的翻转。
         6. **输出**：按 `list1` 的顺序沿各个节点顺序输出即可。

2. **问题**：时间超限

   1. **解决1**：使用 `2` 个双向链表实现翻转

      参考资料：《数据结构》-CST 2021-第一次习题课-用2个单向链表实现翻转

      修改前，翻转操作的时间复杂度为 `O(n)` （ `n` 为待翻转序列的长度）：

      ```c++
      void reverse(){
          int t = suc[headerPos];
      		... // 省略
          while(t != trailerPos){
              ... // 省略
              if(suc[current] == rightPointer){
                  suc[current] = pre[current];
                  pre[current] = leftPointer;
                  pre[rightPointer] = mark_first;
                  printf("%c\n", 'T');
                  break;
              }
              else{
                  t = suc[current];
                  swap(pre[current], suc[current]);
              }
          }
      }
      ```

      修改后，翻转操作的时间复杂度为 `O(1)` ：

      ```c++
      void reverse(){
          ... // 省略
          int temp1 = nextNode[list1.leftPointer], temp2 = nextNode[list2.leftPointer];
          // 更新 list1
          nextNode[list1.leftPointer] = nextNode[list2.rightPointer];
          prevNode[nextNode[list2.rightPointer]] = list1.leftPointer;
          nextNode[list2.leftPointer] = nextNode[list1.rightPointer];
          prevNode[nextNode[list1.rightPointer]] = list2.leftPointer;
          // 更新 list2
          nextNode[list2.rightPointer] = temp1;
          prevNode[temp1] = list2.rightPointer; 
          nextNode[list1.rightPointer] = temp2;
          prevNode[temp2] = list1.rightPointer;
          // 交换 pointers
          swap(list1.rightPointer, list2.leftPointer);
          ... // 省略
      }
      ```

   2. **解决2**：输入输出用 `fgets` ,  `getchar` ,  `putchar` 优化

      以下代码注释部分均为优化前的代码：

      ```c++
      // cin >> text;
      fgets(text, sizeof(text), stdin); // 输入初始文本
      text[strlen(text) - 1] = '\0';
      
      // cin >> instruct;
      instruct = getchar();
      getchar();
      
      // cout << "T" << endl;
      putchar('T');
      putchar('\n');
      
      while(t != trailer){
          // cout << content[t];
        	putchar(content[t]);
          t = nextNode[t];
      }
      // cout << endl;
      putchar('\n');
      ```

      缓冲区直接读入、输出，比输入流、输出流要快很多，起到了很好的优化效果。

3. **复杂度估算**：

   1. 时间复杂度： `O(m + n) ~ O(n * (n + m))` （ `m` 为输入的初始序列长度） 

      设初始序列长度为 `m` ，初始化链表的时间复杂度为 `m` ；共 `n` 个操作，除了输出操作时间复杂度为当前序列长度（初始序列长度为 `m` ，则当前序列长度上界为 `n + m` ，因此输出的时间复杂度上界为 `O(n + m)` ），其他操作均为 `O(1)` ，因此该部分时间复杂度为 `n ~ n * (n + m)`  （其中 `m` 为输入的初始序列长度）。所以总时间复杂度为 `O(m + n) ~ O(m + n * (n + m))`  即 `O(m + n) ~ O(n * (n + m))`。

   2. 空间复杂度： `O(1)`

      所有操作均为就地操作，且占用空间与输入无关，因此全部空间复杂度为 `O(1)` 。

