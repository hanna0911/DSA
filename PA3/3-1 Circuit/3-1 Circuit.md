### 3-1 Circuit

1. **数据结构与算法**：字典树

   1. **构思**：由题意，需实现在有效集合（当前元件`i`间隔不超过`k`的元件）中插入元件`i-k-2`、删除元件`i+k+1`、 查询当前在有效集合中异或值最大的元件，其中元件为二进制数（或`01`串），可以想到用字典树来实现这些功能。

   2. **原理**：字典树的插入、删除、查询

   3. **实现要点**：

      1. **建树**：该字典树为二叉树（因为只有`0`、`1`两个不同的字符），因此字典树节点`treeNode`只需存储左孩子`left`、右孩子`right`、以及经过该点的路径数`count`（便于删除时统计是否要删除该路径）；字典树根节点为`root = 0`，具有插入路径、删除路径、查询某路径的异或值最大路径功能。初始建树需要加入加好`id`（元件序号）为`0~k+1`的路径。

      2. **查询（及查询前的插入、删除）**：

         从后往前进行“窗口”移动（“窗口”为有效集合），之所以从后往前是为了确保，如若插入路径相同（二进制值相同）的不同元件多次，则最新记录的一定是元件序号`id`最小的那个（最后更新的）。

         对于序号在`0~k+1`中的元件`i`，每次更新有效集合，只需多加原集合右侧的一个路径（序号为`i+k+1`）；对于序号在`k+2~n-(k+2)`间的元件`i` ，每次需多加右侧一个路经`i+k+1`、删掉原有最左侧的路经`i-k-2`（或者对`n-(k+1)~k+1`间的元件`i`，无需插入、删除，直接查询）；对于`n-(k+1)~n-1`间的元件`i`，需删掉原有最左侧一个路经`i-k-2`。

         插入路径与删除路径，均规定字符为`0`则为左孩子、`1`为右孩子，经过次数相应`+1`或`-1`。插入路径的叶子节点的左孩子值`left`存储该元件的`id`以便于查询时使用。删除路径时，若`count`已经减为`0`，则可将该节点设为`invalid`，即彻底切断路径；若`count`没有减为`0`则无需额外处理。

         查询路径，为求与当前元件对应异或值最大的元件，只需从首位开始便尽可能选取与当前元件相异的路径。

      3. **输出**：只需逆序输出上述从后往前的查询结果即可。需要注意的是，前`k+2`个输入一样的情况需要特判，即第`0`个元件可能会输出自己`0`，只需改为`1`即可。

2. **问题**：查询时输出最靠前（且不能输出自己）的元件序号

   **解决**：一开始使用了从前往后移动“窗口”的方案，无法做到查询时输出最靠前的元件序号，后改为逆序处理元件（“窗口”从后往前移动）。

   对于是否会输出自己的元件序号，因为`k >= 0`，且和不同元件异或必定比和自己相同的元件异或出的结果大，因此但凡不是作为第`0`个元件（其前面不再有元件可以插入字典树来更新答案）且第`0~k+1`个元件均一模一样，否则必定不会输出自己。因此修改时，对第`0`个元件的输出答案做了特判，如果发现存储的答案是`0`即它自己，则输出它的下一个`1`。

3. **复杂度估算**：

   1. **时间复杂度**：`O(n)` 

      读入数据，以及后续进行插入、删除、查询操作均为`n`次，而插入、删除、查询的时间复杂度为字典树的深度，即`O(64) = O(1)`，因此总的时间复杂度为`O(n)`。

   2. **空间复杂度**： `O(n)` 

      每个元件占用空间`O(64) = O(1)`，一共需存储`n`个元件信息，总空间复杂度为`O(n)`（用`Bitmap`存储）。

      而字典树同一时刻最多有`k`条路径，每条路径长度为`O(64) = O(1)`，总空间复杂度为`O(k)`。总空间复杂度应为`O(n + k)`，但在本题做了优化，如果`k > n`则会直接将全部的`n`个元件都插入字典树中，后续不在与`k`有关， 即字典树的空间复杂度为`O(n)`；若`k <= n`，很自然的有`O(n + k) <= O(n + n) <= O(n)`，因此字典树的空间复杂度也为`O(n)`。

      因此总的空间复杂度为`O(n)`。

