### 3-3 kth

1. **数据结构与算法**：堆

   1. **构思**：以题目所给的数据量，通过排序来获得第`k`小的值，时间复杂度至少为`O(n^3 * logn^3)`，显然不合适。因此想到用优先级队列中的最小堆，只需要删除堆顶`k`次即可获得第`k`小的值。

   2. **原理**：堆的插入、删除

   3. **实现要点**：

      1. **排序**：对每一坐标分量进行排序，通过控制变量法来设计`qsort`的比较器`compare`。以下以`x`分量为例：

         ```c++
         int compare_x(const void * a, const void * b){ // x分量比较器，控制住y、z分量相同
         		return compare(*(int*)a, 1, 1, *(int*)b, 1, 1);
         }
         
         qsort(a, n, sizeof(a[0]), compare_x); // 对x分量排序
         ```

         需要强调的是，此排序是按从大到小降序，受限于本题所提供的比较接口。

      2. **堆操作**：对x、y、z方向上每一分量从大到小排序后，可知此时最小的元素一定是`(n-1, n-1, n-1)`，先令其入堆。而对于剩下的元素，为了使得第`i`次删除的堆顶元素一定是所有`n^3`个元素中的第`i`小的，规定每当删除元素`cur`，需要在堆中加入在三位拓扑结构中与之相连的点，且为了不重复添加点，需要人为做出规定：若元素`cur`在x轴上，则沿x、y、z三个方向上相邻的点全需入堆；若元素`cur`在xy平面上（刨去在x轴上的），则将沿y、z两个方向上相邻的点入堆；若元素`cur`属于剩下的情况（即在z轴上、或在yz平面上、或在xz平面上），则仅将z方向上与之相邻的点入堆。

         伪代码如下：

         ```c++
         // 规定: x轴上的点出1入3, xy平面上的点出1入2, z轴及yz面及xz面上的点出1入1
         Node cur = {n - 1, n - 1, n - 1};
         heap.insert(cur);
         int del = 0;
         while(del < k){
         		cur = heap.delMin(); // 摘除堆顶并存到cur
         		// 将与cur相连的点加入堆中 (按照规定界定相连的点并添加)
             if(cur.y == n - 1 && cur.z == n - 1){ // x轴上的点
                 heap.insert({cur.x - 1, cur.y, cur.z});
                 heap.insert({cur.x, cur.y - 1, cur.z});
                 heap.insert({cur.x, cur.y, cur.z - 1});
             }
             else if(cur.z == n - 1){ // xy面
                 heap.insert({cur.x, cur.y - 1, cur.z});
                 heap.insert({cur.x, cur.y, cur.z - 1});
             }
             else heap.insert({cur.x, cur.y, cur.z - 1}); // 其他只需沿z方向移动
             del++;
         }
         ```

         入堆使用到的上滤、删除堆顶元素用到的下滤均为邓老师上课所讲，实现代码引自邓老师网站。

2. **问题**：如何确保不重复添加节点进堆

   **解决**：基于序列大小关系规定不同位置的点，在出堆时同时加入不同方向上与其相邻的点（如上文所说规定方式）。

3. **复杂度估算**：

   1. **时间复杂度**：`O(nlogn + klogk)` 

      建立x、y、z三个分量对应的坐标数组所需时间复杂度为`O(n)`，对x、y、z分量分别排序所需时间复杂度为`O(nlogn)`。

      堆中添加节点的时间复杂度与堆中数据规模有关，而堆中数据从始至终不超过`2*k`（以最差的出一入三，即x轴上的点来计算堆中元素个数），因此堆的每次添加操作（其中的上滤操作）时间复杂度应为`O(log(2*k)) = O(logk)`。同理，每次删除堆顶元素（其中的下滤操作）时间复杂度也为`O(logk)`。而插入操作最多为`3*k`次，删除操作为`k`次，因此堆操作的总时间复杂度为`O(klogk)`。

      总的时间复杂度为`O(nlogn + klogk)`。

   2. **空间复杂度**： `O(n + k)` 

      x、y、z三个分量对应的坐标数组所需空间为`O(3*n) = O(n)`，堆所需空间为堆的数据规模，即上述分析过的`O(2*k) = O(k)`，因此总空间复杂度为`O(n + k)`。

