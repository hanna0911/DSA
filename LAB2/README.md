# CST2021F LAB2 HashFun

------

请下载附件中的数据集、实验框架和样例。

[dataset.zip](https://dsa.cs.tsinghua.edu.cn/oj/attachment/ac76/ac7665ae245bb06a1717840b884ead4669694632.zip)

[framework.zip](https://dsa.cs.tsinghua.edu.cn/oj/attachment/1a95/1a958972901eb461f6fcb6c3204af0433f19cf11.zip)

附件下载后的名称是一串字母和数字的乱码，属于正常现象。

framework.zip 内含:

```
实验框架：
main.cpp
hashtable.cpp
hashtable.h
Makefile
用于帮助理解输入输出格式的样例数据:
1.in
1.out
```

使用Makefile不是必须的，你也可以使用Visual Studio工程等方式来管理多个源代码文件。

dataset.zip 内含:

```
poj.txt
hdu.txt
```

### **0. 背景知识和准备工作**

**不占分数，但有助于你理解实验背景和实验框架。你可以先跳过这一部分，之后遇到困难随时查阅。如果你使用windows, 建议阅读这一部分**

”字符串到数字的对应关系“在实际应用中很常见。比如查通讯录，需要从姓名（字符串）对应到电话号码（数字）。我们可以使用哈希表来存储”字符串到数字的对应关系“。

哈希表有多种实现方法，性能表现不同。题目会给出一个哈希表的程序框架，你需要在框架上，实现不同的哈希表，构造测试数据，进行性能测试，并分析测试结果。

你需要处理utf-8编码的字符串（包含中文和其他一些特殊字符），体会对它们做哈希和ascii字符串有何不同。

**utf-8编码简单介绍：**

utf-8编码是一种“变长编码”，即不同字符所占的字节数目可能不同。

一个utf-8字符可能是1~6个字节，但1~3个字节的utf-8字符已经覆盖了大部分会用到的字符。我们给出的数据中只包含1~3个字节的utf-8字符。

长度1字节的utf-8字符，和ascii码相同，且最高位一定是0。长度不为1字节的utf-8字符，最高位一定是1。

长度2字节的utf-8字符，第一个字节最高三位一定是110，第二个字节最高两位一定是10。

长度3字节的utf-8字符，第一个字节最高四位一定是1110，第二、三个字节的最高两位一定是10。

按照这种编码方式，在将字符按照utf-8的规则转换为一串字节后，我们还可以将这一串字节中的字符区分开来。

utf-8是Mac OS X和linux下的默认编码方式，但并不是windows默认的编码。

如果感觉这些信息不够你完成题目，可以通过搜索引擎进一步了解utf-8编码。

**windows10需要修改编码为utf-8：**

如果你使用的是windows10, 我们建议你使用windows subsystem for linux（默认使用utf-8编码)完成本题。

如果你很希望在windows的控制台或powershell中完成本题（包括windows下的大部分C++ IDE, 如visual studio），你需要开启windows10区域设置中的“Beta版：使用Unicode UTF-8提供全球语言支持”选项。之后在powershell或cmd的属性中，看到“当前代码页”是65001（UTF-8），就说明编码已经调整好了。

为了确保你理解了utf-8编码是如何工作的，可以尝试使用`scanf("%s",char_array)`和`printf('%s', char_array)`来向C++程序输入一个中文字符串并打印出来。C++中的char类型只能保存一个字节，然后你可以把char数组中的每个字节打印出来看看，这些字节是如何与中文字符串的utf-8编码对应的。（网上可以容易地搜索到中文和utf8编码在线转换的网站）

如果遇到在命令行输入输出中文字符的bug，可以尝试使用文件输入输出fscanf, fprintf进行调试。我们保证框架所给出的输入输出方式能在OJ上正常运行。

**一些帮助实验框架阅读理解的题目**

（想明白这些问题可以帮助你理解实验框架，但请你不要在实验报告中回答这些问题，它们不占分）：

\1. hashtable结构体中有两个指针成员变量` hashing_strategy* my_hashing; collision_strategy* my_collision`; 如果直接用hashing_strategy和collision_strategy结构体作为hashtable的成员，会出现什么问题？（提示：强制将子类转换为基类时会发生什么？）

\2. hashtable中的插入和查询都调用了冲突解决函数`(*my_collision)( )`分别起到什么作用？

\3. `my_collision->init()`可能有什么用处？

\4. 如果插入一个已经存在的词条，现在的实验框架会如何处理？

\5. 如果插入新词条时发现哈希表已满，现在的实验框架会如何处理？（**注意，你不需要修改框架在这里的处理方式，但需要在构造测试数据时避免发生这种哈希表已满的状况**)

\6. 如果进行查找时不存在对应的结果，现在的实验框架会如何处理？

\7. 代码中给出了一个常量 const int TABLE_SIZE = 499883; 它是质数并且除4余3，这在哈希算法中代表什么？（**你在测试时，可以使用其他的具有类似性质的数字来作为哈希表的大小，不必局限于499883**, 通过搜索引擎可以容易地找到质数筛法的代码。）

### **1. 编写数据生成器**

我们提供了`poj.txt`和`hdu.txt`两个数据集，是poj.org和acm.hdu.edu.cn两个做题网站上的用户ID、排名和做题量。

你需要根据这两个数据集，用C++编写程序作为数据生成器（可以使用OJ上禁止使用的头文件），以`poj.txt`或`hdu.txt`为输入时，能够输出格式类似于`1.in`的测试数据。数据生成器的源代码大小不应超过10KB。

需要保证每条映射关系只进行一次插入操作。

每一行一个操作，每一行的第一个数字表示操作类型。

- 数字是0表示给出一条需要插入哈希表的“字符串-数字”映射关系，

- 数字是1表示查询某个字符串对应的数字（不存在时认为映射到-1），

- 数字是2表示输入结束。

你应当编写一个程序，以`poj.txt`或`hdu.txt`为输入，提供不同的命令行参数，可以生成不同的测试数据。

支持的命令行参数至少需要包括：测试数据中插入操作的次数、查询操作的次数。

数据生成器应当具有一定的随机性，即用同样的命令行参数执行数据生成器，可以产生不同的测试数据。

这些测试数据应当具有适当的性质，可以用来比较之后实现的各种哈希策略。为此，你可能需要在实现不同的哈希策略后，返回来修改数据生成器。

### **2. 不同哈希策略的实现**

你需要在我们提供的哈希表框架的基础上实现不同的哈希策略。最终提交的版本中，除非题目中特别说明（公共溢出区策略的实现），不允许修改已经提供的类和函数，只允许你实现更多的strategy结构体。

我们的哈希表框架使用了Strategy Pattern，你需要继承`hashing_strategy`和`collision_strategy`, 实现更多的哈希函数方案和冲突处理方案。

具体地：

1. 继承hashing_strategy, 实现一种针对ascii字符串(即来自poj.txt的数据）设计的哈希函数。
2. 继承hashing_strategy, 实现一种针对utf-8字符串（即来自hdu.txt的数据，只包含1~3字节的utf-8字符）设计的哈希函数。
3. 继承collision_strategy, 实现双向平方试探策略。
4. 继承collision_strategy, 实现公共溢出区策略。

（关于实现公共溢出区策略的说明：将`hashtable.Table[]`的一部分作为哈希表，一部分作为公共溢出区。为此，可以修改框架中的hashtable::query()和hashtable::insert()函数，例如判断当前冲突排解策略为公共溢出区策略时，更改*my_hashing调用时传入的参数table_size。或者，为冲突排解策略增加一个成员函数，通过这个成员函数获得*my_hashing调用时传入的参数。）

要求中的”针对utf-8字符串"意味着不要把字符串当成一串字节来处理，而是当成“一串utf-8字符”来处理，从字符串中把一个一个的utf-8字符提取出来， 以utf-8字符为哈希函数处理的基本元素。

在实验报告中，简要描述你的两个哈希函数的实现思路、两个冲突处理策略的实现方法。（不得超过400字，超出1字扣1分）

对哈希函数的描述可以只用“纯数学公式”。对冲突处理的描述需要结合代码细节。

### **3. 进行测试**

你可以对`main.cpp`做一些修改，从而可以使用命令行参数方便地选择采用哪种哈希函数(hashing)策略、哪种冲突处理(collision)策略。

现在加上最开始提供的哈希函数和冲突处理策略，你有3种哈希函数、3种冲突处理策略，两两组合，实际上有9种不同的哈希表。

对于测试数据，至少应当有来自`poj.txt`和`hdu.txt`的两种测试数据。

另外，不同数据规模、不同的插入/查询操作比例、插入和查询的不同分布方式，都可以构造出不同的测试数据。

你需要构造6组不同的数据，3组来自`poj.txt`, 3组来自`hdu.txt`。

然后，你需要进行 9种不同的哈希表 X 6种不同的数据，共54次测试，获取运行时间数据，汇总成文本文档，或.csv表格等便于你自己理解的格式。

如果某些程序运行完毕需要的时间过长，不必将其运行完，直接杀死程序，在结果中用“大于Y秒”表示即可。（Y是你自己设定的一个门槛）

如果你编写的程序有可能出现数组越界的情况，可以使用 -fsanitize=address 编译选项来编译程序，使得数组越界时程序必然直接崩溃。

测试时，尽量关闭电脑上的其他程序以减少干扰。哈希表的大小需要自己选择一个合适的。

强烈建议你编写脚本进行这个重复测试工作，而不是手工重复54次实验。

需要在实验报告中简单描述你的6个测试数据的构造方法、数据特征。

（不得超出300字，超出1字扣1分）

### **4. 分析结果**

在实验报告中回答这些问题：

1. 将utf-8字符串“当作”ascii字符串进行处理，使用针对ascii字符串的哈希函数，实际效果如何（相比“针对utf-8字符串设计的哈希函数）？为什么？
2. 线性试探和双向平方试探的性能比较情况如何？为什么是这样？
3. 在测试数据中，开放散列(公共溢出区)和封闭散列(使用试探链)的比较情况如何，谁占优势？在你的测试结果中不占优势的处理策略，处理什么样的实际数据时会更适合使用？
4. 设计哈希函数时，我们往往假定字符串每个位置上出现字符集内每个字符的概率都是相等的，但实际的数据集往往并不满足这一点。这可能造成什么影响？
5. 对于”字符串到数字映射“问题(给定一组字符串以及它们各自对应的数字，然后多次查询某个字符串对应的数字，可能会在中途更新某个字符串对应的数字)，哈希表并不总是最优方案。请描述一种输入数据，再举出一种哈希表之外的数据结构，对这种数据，这种数据结构能比哈希表更高效地解决”字符串到数字映射”问题。

（不得超出300字，超出1字扣一分）

### **5. 最终提交**

记得使用你的代码进行一次黑盒测试。数据范围不大，仅用于验证你的代码正确性，第一个测试数据是1.in和1.out。

提交黑盒测试时，参照PA handbook的说明：代码如果含有多个文件，可以将所有代码置于顶层目录直接打包（.zip、.tar、.tar.gz 等格式）提交，目录和文件名不能有空格、中文、特殊字符。

你需要在解题报告处用一个zip压缩包提交这些内容，且仅提交这些内容. (如果提交了额外的内容，每1KB扣1分)

1. 你所编写的数据生成器的源代码，和生成数据时使用的命令行参数。但**不要**提交你生成的数据，也**不要**提交poj.txt和hdu.txt。
2. 你进行修改后的实验框架，包含你实现的更多哈希函数策略、冲突排解策略，但不应实质改动框架中原有的函数和类。
3. 测试得到的结果。其格式应当便于理解，或对格式有说明。
4. 实验报告，包括一段”不得超出400字“的内容，和两段”不得超出300字“的内容。字数统计规则为 typora 字数统计的“词”。