## CST2021F LAB1 Zuma 解题报告

> 姓名：王昊华
>
> 班级：计04
>
> 学号：2020010942



### 01.cpp

1. **Runtime Error**

2. **无法处理消除发生在最左侧时的情况，导致下标越界**： `play()` 函数中，条件判断语句 `if (size >= 3)` 中的 `play(left - 1)` 指令没有考虑 `left = 0` 的情况，在调用 `play(left - 1)` 后 `rank = left - 1` 即 `rank = -1`，后执行 `a.at(rank)` 出现 `string a` 下标越界的情况。

3. 测例：

 ```c++
AA
1
0 A
 ```

4. **构造在执行消除后调用到 `play(-1)` （即消除的左侧闭区间为 `0` ）的测例**：测例在位置为`0`处插入`A`后，`size = right - left = 3 - 0 = 3`，进入 `if (size >= 3)` 判断语句中，并调用 `play(left - 1)` 即 `play(-1)`，因此在执行 `a.at(rank)` 即 `a.at(-1)` 时出现 `string a` 下标越界的情况。



### 02.cpp

1. **Runtime Error**

2. **没考虑连消后为空的情况，导致下标越界**： `play()` 函数的条件判断语句 `if (size >= 3)` 中，在调用 `play(next)` 前，没有判断在连消 `a.erase(left, size)` 后 `string a` 为空的情况，因此在调用 `play(next)` 时候，执行 `a.at(rank)` 时出现 `string a` 下标越界的情况。

3. 测例：

 ```c++
AA
1
0 A
 ```

4. **构造在执行消除后为空串的测例**：测例在位置为`0`处插入`A`后，`size = right - left = 3 - 0 = 3`，进入 `if (size >= 3)` 判断语句中，因为 `left - 1 < 0` 而不进入 `if (left - 1 >= 0)` 语句，直接调用 `play(next)` 即 `play(left)` 即 `play(0)`，但由于执行完 `a.erase(left, size)` 后 `string a` 已为空串，因此调用 `play(0)` 并执行 `a.at(rank)` 即 `a.at(0)` 时出现 `string a` 下标越界的情况。



### 03.cpp

1. **Time Limit Exceeded**
2. **时间超限**：在 `string` 头部进行 `n` 次插入操作的时间复杂度为 `O(n * (n + m))` ，根据该题数据范围 `0 ≤ n ≤ 500000, 0 ≤ m ≤ 500000` ， `O(n * (n + m))` 的时间复杂度会使得运行时间远超过题目要求的时间限制 `1.5 sec` 。
3. 测例生成代码：

```python
with open("03.in","w") as f:
    f.write("AB" * 250000)
    f.write("\n500000")
    f.write("\n0 B\n0 A" * 250000)
```

4. **对照最大的输入数据范围进行构造，并保证每次插入均在头部，且不会触发消除**：对长度为 `500000` 的 `string a = "ABAB...AB"` 做 `500000` 次在首位插入 `0 X` （其中 `X` 交替为 `B` 与 `A` ）的操作；由于构造样例的特殊性，每次插入均不会触发消除，保证了最差的情况即 `n` 次头部插入；时间复杂度为 `O(n * (n + m))`，耗时约 `10 - 15 sec` ，显著大于该题要求的 `1.5 sec` 。



### 04.cpp

1. **Wrong Answer**

2. **错误消除**： `play()` 函数的循环语句 `while (left > 0 && a.at(left) == color) --left;` 与 `while (right < a.size() && a.at(right) == color) ++right;` 使得在最终的 `left > 0` 的情况下，待消除区间 `[left, right)` 比应有的区间左侧长`1`，计算出的 `size` 会比正确的 `size` 大`1`，导致错误消除（消除不该消除的字串）。

3. 测例：

 ```c++
AB
1
2 B
 ```

4. **构造插入新字符后，连续字符为 `2` 个的测例**：测例在位置为`2`处插入`B`后，`ABB` 字串调用 `play(rank)` 即 `play(2)` 后执行2个 `while` 循环语句，后计算出的 `left = 0`、`right = 3`，因此 `size = right - left = 3 - 0 = 3`，但实际上`B`的连续个数应为`2`而非`3`，程序错误计算了 `size` 后进入条件判断语句 `if (size >= 3)`，错误消除了 `ABB` 这`3`个并不连续相等的字串。



### 05.cpp

1. **Wrong Answer**

2.  **没考虑初始序列为空**： `main()` 主函数中的输入 `cin >> a;` 无法处理初始序列为空的情况。

3. 测例：

 ```c++

1
0 A
 ```

4. **构造初始序列为空的测例**：初始序列为空， `cin >> a;` 不会读取 `a = ""` ，而是会认为第二行的 `1` 是 `string a` ，进而造成后续读取 `cin >> m;` 等操作均出现错位的问题。



### 06.cpp

1. **Wrong Answer**
2. **块与块临界处的插入有误**： `play()` 函数中，当块 `p[pos.first]` 过长，即 `plen[pos.first] >= plen_bound` 时，该代码也不会先调用 `p2a()` 将 `p` “组装”回 `a`，再调用 `a2p()` 将  `a` 切分成若干长度控制在 `plen_bound` 之内的 `p` 块；导致后续再调用 `play()` 进行插入操作时，`succ_len = plen[pos.first] - pos.second` 计算时 `plen[pos.first]` 若已达到或超过 `plen_bound = 1 << 12` 的大小，则后续执行 `memmove(cur + 1, cur, succ_len)` 时，将长度为 `succ_len` 的字符串组往后挪 `1` 位的时候会覆盖到 `p[pos.first + 1]` 块的前端内容，最终结果错误。
3. 测例生成代码：

```python
with open("06.in","w") as f:
    f.write("AB" * 1024)
    f.write("A\n2050\n")
    for i in range(0, 1023):
        f.write(f"{i * 2 * 2} A\n")
        f.write(f"{(i * 2 + 1) * 2} B\n")
    f.write("4092 A\n4094 C\n4096 D\n4095 E")
```

4. **构造在执行跨块临界处的插入操作时，相邻 `2` 个块中，前者块的数据量已达 `plen_bound` 个（或更多），后者块中有数据即可（至少有 `1` 个）的测例**：因为初始序列会被分块成每一块目标长度小于等于 `plen_target = 1 << 11` 的块，因此为达到 `plen_bound = 1 << 12` 的临界条件，首先需要给已分好的每一个块均至少插入 `plen_bound - plen_target = 1 << 11` 个字符（不触发消除的情况下）。因此测试样例的初始序列长度为 `1 << 11 = 2048` ，后面的 `2050` 个操作中，先进行 `2048` 次平凡的插入操作将 `p[0]` 的 `1 << 12 = 4096` 位（下标为 `0 - 4095` ）均填满；再进行 `2` 次插入操作，第一次插入（ `4096 D` ）时因为 `p[1]` 中还没有字符，不发生覆盖，而第二次插入（ `4095 E` ）时因为 `p[1]` 中已有字符而在 `memmove` 将其覆盖（最后 `3` 个插入操作之所以不用 `A` 、 `B` ，而是换用 `C` 、 `D` 、 `E` ，是为了更好区分插入的/被覆盖的字符）。具体而言，仅考虑最后一次插入操作（ `4095 E` ）在 `p[0][4094]` 、  `p[0][4095]` 、  `p[0][4096]` （ `p[1][0]` ）、  `p[0][4097]` （ `p[1][1]` ） 、 `p[0][4098]`（ `p[1][2]` ） 这 `5` 个字符位置处的改动，在插入前这 `5` 处分别为 `CBDA__` （ __ 表示空），在输入 `4095 E` 再调用 `play()` ，计算出 `succ_len = plen[pos.first] - pos.second = 4096 - 4095 = 1` ，再执行 `memmove(cur + 1, cur, succ_len)` 即 `memmove(cur + 1, cur, 1)` 时（ `cur` 为 `p[0][4095]` 处的指针），移动后的结果是 `CBBA__` ，这是因为将 `4095` 处的B向后移动了 `succ_len = 1` 位，导致覆盖了原本 `p[1][0]` 处的字符 `D` ，插入 `E` 后答案该 `5` 位为 `CEBBA` ，这是错误答案，正确答案应为 `CEBDA` 。



### 07.cpp

1. **Wrong Answer**
2. **跨块消除有误**：在 `play()` 函数中计算需要消除的开区间 `(l, r)` 处，进入 `while (l.first >= 0 && get(l) == ch)` 的情况，对于 `if (l.second < 0 && l.first >= 0)` 的语句，最多只会进入 `1` 次 `if` 语句，即最多只会进行 `1` 次 `l.first--` ；即最多只会查看前 `1` 维可能被消除的字串，而无法判断前 `2` 维处是否有可能被消除的字串，因此漏消。
3. 测例生成代码：

```python
with open("07.in","w") as f:
    f.write("CD" * 1024)
    f.write("AABB" * 341)
    f.write("AA")
    f.write("BA" * 341)
    f.write("CCDD" * 512)
    f.write("\n2\n3413 A\n2050 C")
```

4. **构造至少有 `3` 块，其中第 `2` 块中间块在某次操作后其中所有数据被全部消除，在下一次操作会令第 `1` 、 `3` 块中数据实现连消的测例**：构造的测例，初始字串长度为 `6144` ，在输入后被分块为 `3` 部分——`CDCD...CD` （ `2048` 个字符）、 `AABBAABB...AABB` （ `1364` 个字符） + `AA` + `BABA...BA` （ `682` 个字符）、 `CCDDCCDD...CCDD` （ `2048` 个字符），分别存在 `p[0]` 、 `p[1]` 、 `p[2]` 这 `3` 个块中，每个块存储 `plen_target = 1 << 11 = 2048` 个字符。第一个操作为 `3413 A` ，即在 `p[1][1365]` 处插入字符 `A`，插入后会导致 `p[1]` 块连消至 `p[1] = ""` 为空，此时 `p[0]` 、 `p[2]` 仍不变。第二个操作为 `2050 C`  ，即在 `p[2][2]` 处插入字符 `C` ，此时触发 `CCC` 消除后，本应触发后续 `p[0]` 与 `p[2]` 中的 `DDD` 连消，进而不断发生跨越 `p` 的 `2` 维的块之间的连消，但由于计算需要消除的区间 `if (l.second < 0 && l.first >= 0)` 的语句最多只会进入 `1` 次，即最多只会进行 `1` 次 `l.first--` ；即最多只会查看前 `1` 维即 `p[1]` 中可能被消除的字串，然而此时 `p[0]` 为空，而无法判断前 `2` 维即 `p[0]` 中是否有可能被消除的字串，因此漏消，结果错误。



### 08.cpp

1. **Wrong Answer**
2. **没有考虑连消**：在 `play()` 函数中计算需要消除的开区间 `(l, r)` 只会进行一次，即最多计算出进行一次消除的开区间 `(l, r)` 以供后续消除，因此不能实现连消。
3. 测例：

```c++
AABBA
1
3 B
```

4. **构造会发生连消的测例**：在 `play()` 函数中计算需要消除的开区间 `(l, r)` 只会进行一次，即最多计算出进行一次消除的开区间 `(l, r) = (1, 5)` 以供后续消除，即计算得到的 `lbound.second = 1` , `rbound.second = 5` （二者的 `first` 属性均为 `0` ，可忽略），消除区间大小为 `eliminated = 3` ，因此只消除了区间 `(1, 5)` 的  `BBB` ，而漏消了后续本应继续连消的 `AAA` 。



### 09.cpp

1. **Runtime Error**
2. **没考虑待消除区间在同一块中的情况，导致访问没被定义的内存区域**：在 `play()` 函数中执行消除部分，没有考虑 `l.first == r.first` 即待消除的区间在同一个 `p` 块中的情况，导致 `size_t plen` 数组赋值错误，后续调用 `p2a()` 时 `memcpy(&a[copied], p[i], plen[i])` 中由于错误的 `plen[i]` ，因而读取没有定义的内存区域的值，报错。
3. 测例：

```c++
AABBC
1
2 B
```

4. **构造待消除区间在同一块中的测例**：在 `play()` 函数中执行消除部分，没有考虑 `l.first == r.first` 即待消除的区间在同一个 `p` 块中的情况（此测例 `l.first` 与 `r.first` 均为 `0` ），导致后续会以 `l.first >= 0` 与 `r.first < pn` 即待消除区间在不同的 `p` 块中的情况来错误计算 `len =  plen[r.first] - r.second = -3` ，赋值给 `plen[r.first] = len = 2 ^ 64 + 1 + len` （ `size_t` 遇负数会溢出）即 `plen[0] = 18446744073709551613`  ；因此在后续调用 `p2a()` 时， `memcpy(&a[copied], p[i], plen[i])` 即 `memcpy(&a[0], p[0], plen[0])` 会读取到 `p[0][0]` 至 `p[0][18446744073709551613 - 1]` 的共 `18446744073709551613` 个内存区域的值；而 `p[1 << 12][plen_bound]` 的全部内存区域大小为 `0` 至 `(1 << 12) * plen_bound = (1 << 12) * (1 << 12) = 2 ^ 24 = 16777216` ，很显然 `18446744073709551613` 显著大于 `p` 的全部内存区域大小，因此这一行为会读取并没有被定义的内存区域的值，造成 `Bus Error` 。



### 10.cpp

1. **Wrong Answer**
2. **错误设置块 `p` 的长度，导致无法根据各块 `p` 来正确更新 `a`** ：在 `play` 执行消除处，`for (int i = l.first; i < r.first; i++)` 的起始值应为 `l.first + 1` ，此处为 `l.first` 会导致本来要消除的左开右开区间 `(l, r)` 变为左闭右开的区间 `[l, r)` ，使得本来不应置为 `0` 的 `plen[l.first]` 被误置为 `0` ，`p[l.first]` 因 `plen[l.first] = 0` 而消失，在后续 `p2a` 等操作时出现问题。
3. 测例：

```c++
ABAABB
2
2 A
0 A
```

4. **构造会触发消除并致使某块的 `plen` 被错误置为 `0` ，且后续操作与该被错误置长的块有关的测例**：该测例执行第一个操作 `2 A` 时，消除区间为 `(l, r)` ，其中 `l = (-1, -1)` , `r = (1, 0)` ；然而由于 `play` 执行消除处，`for (int i = l.first; i < r.first; i++)` 在执行 `plen[i]` 置 `0` 消除操作时，错误的选择了闭区间 `[l, r)` （即 `for` 循环起始值应为 `l.first + 1` ），导致 `p[0]` 本不为空，但由于 `plen[0] = 0` 而在后续操作以及 `p2a` 转换时均出现问题。比如在执行第二个操作 `0 A` 后，应输出 `AA` ，但由于 `p2a` 转换时始终认为 `p[0]` 为空，因此从来没有真正以 `p[0]` 的实际状态来更新 `a` ，而是单纯依靠初始值的 `a = "ABAABB"` 以及 `alen` 的大小在掐出所谓的操作后的 `a` ，导致错误输出了初始值 `a` 的前 `alen = 2` 位 `AB` ，而非正确答案 `AA` 。

