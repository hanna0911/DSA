### 2-6 Hacker

1. **数据结构与算法**：独立链哈希表

   1. **构思**：

      由题意，需保存原始字符串（明文 `value` ）以及通过 `crc32` 加密后 `32` 位整数（密文 `key` ，即关键码），后续要根据给定 `key` 查询 `value` 的 很显然是用哈希表来存储数据。

   2. **原理**：独立链哈希表、数组链表

   3. **实现要点**：

      1. **构建哈希表**：

         独立链哈希表分为两个部分——邻接表链表表头 `int * head` 、内存池 `Entry * bucket` 。结构体 `Entry` 中除去存储 `key` 、`value` ，还包含 `int next` 用于存放下一 `Entry` 所在位置（在内存池 `bucket` 中的下标），即模拟链表。

         内存池 `bucket` 大小最多为 `5000800` ，因为初始字符串个数 `18^5 + 18^4 + 18^3 + 18^2 + 18^1 = 2000718` ，后续  `1000000` 个操作中最多增添 `1000000 * 3 = 3000000` 个新键值对（假设每次操作均构建长度为 `6~8` 的不重复字符串）。有一栈顶指针 `int top` 负责记录当前“内存”分配情况，每次分配新“内存”时均需使栈顶指针上移（ `top++` ）来使其指向下一待分配（未分配）“内存”。

         邻接表表头 `head` ，大小为 `M = 10000871` 。在构建哈希表时，根据关键码取余 `head` 的总大小来确定其存储在哪一个桶中（即 `rank = head % M` ），`head` 中各项初始值均为 `-1` 。一旦有 `Entry` 要被存入下标为 `rank` 的桶，若检查 `head[rank]` 为 `-1` ，则让 `head[rank]` 指向该 `Entry` 在 `bucket` 中的下标；否则顺着该桶的独立链（沿着 `next` 查询即可，与链表遍历访问方法一致）找到结尾处进行插入。

         读入 `salt` 后，用深度优先搜索方法，从原始字符集中递归构造所有符合要求（长度 `≤ 5` ）的字符串 `phrase` ，并转 `19` 进制 `long long` 型作为 `value` ；再利用 `crc32(phrase + salt)` 生成该 `phrase` 对应的 `32` 位整数暗文 `key` 。由此获得符合要求的键值对 `(key, value)` ，按照上述方法插入到哈希表中。

      2. **查询并插入新词条**：

         查询 `key` 的三种情况：在现有哈希表中是否有对应的单个 `value` / 是否出现对应的多个 `value` （该种情况无需再记录 `value` ，而是标记为 `Duplicate` 即可）/ 没有任何对应 `value` 。查询 `key` 的方式与插入 `(key, value)` 的方式基本一致，取余后定位到桶，再沿独立链从头查询至对应 `key` 或尾部，并根据 `key` 的状态（在哈希表中且没有标记 `Duplicate` /在哈希表中但标记了 `Duplicate` /不在哈希表中）按规定输出（输出对应 `value` /输出 `Duplicate` /输出 `No` ）。

         构造循环队列 `Queue` 来存储最后 `k (k ≤ 8)` 条成功破解的明文的首字母顺次连接构成的字符串，使得当队列已满时（已有 `8` 个元素），每当有新元素入队，便令先前最早入队的元素出队。但凡队列元素个数大于 `≥ 6` ，则将对应的 `(key, value)` 插入哈希表中（当然要考虑“重复”情况，若待插入键值对 `(key, value)` 与哈希表中已有键值对 `(key, value)` 相同，不执行任何操作；若待插入键值对中的 `key` 与已有 `key` 相同，但 `value` 不同，那么哈希表中该处 `key` 处标记 `Duplicate` 。当然若哈希表中该 `key` 就不存在，直接插入 `(key, value)` 即可）。

2. **问题**：时间、空间超限

   **解决**：

   一开始用了线性试探的方法来写 `probe4Hit` 函数（用以定位到以 `key` 为键即需要存储 `key, value`的位置）、`probe4Free` 函数（用以定位到以 `key` 为键并且还没有存 `key, value` 的空位置）。但为满足装填因子 `< 50%` ，`rehash` 所用时间过长，且容量翻 `4` 倍开出的空间也过剩，超出空间限制。

   后来换用了哈希表构建方法，改用独立链的方法来存储哈希表，解决了冲突，且时间、空间都满足题意。

3. **复杂度估算**：

   1. **时间复杂度**：`O(n)` 

      构造初始哈希表时间复杂度为常数量级 `O(1)` ，后续 `n` 个操作时间复杂度为 `O(n)` ，每次查询/插入可视作 `O(1)` 的时间效率（均摊时间复杂度为 `O(1 + å)` ，`å` 为装载因子）；因此总时间复杂度（均摊）为 `O(n)` 。

   2. **空间复杂度**： `O(n)` 

      初始建哈希表所有空间为常数量级 `O(1)` ，后续建表一共 `n` 个操作，每次操作增加常数量级 `O(1)` 的空间，总空间复杂度为 `O(n)` 。

