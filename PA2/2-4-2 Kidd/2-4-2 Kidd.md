### 2-4 Kidd

1. **数据结构与算法**：线段树

   1. **构思**：由题意，每次翻特定区间的牌，最后查看任意区间每张牌的翻牌次数之和，可以认识到这是一道 `1D Stabbing Query` 的题目，因此利用线段树这一数据结构；并利用 `lazy tag` 将翻盘计数在父节点进行累积，等需要用到后代节点时再统一将 `lazy tag` 计数向下传递。

   2. **原理**：线段树构建、懒惰标记

   3. **实现要点**：

      1. **待查区间端点去重、离散化**：将所有待查（待翻牌、待查询）区间变为左闭右开区间后，记录端点，后对所有端点做离散化处理——对所有的端点进行排序与去重。
   2. **建立线段树**：将所有离散化后的最短区间单元以叶节点建树，递推式为每一父节点所表示区间为其的左、右孩子区间的并；并初始化该区间翻牌次数、需要向下传递的懒惰标记值，记录区间大小为左闭右开区间的长度。
      3. **进行翻牌与查询操作**：翻牌与查询均用递归实现，当前查询区间 `[left, right]` ⊆ 待查区间 `[left_bound, right_bound]` ，则执行相应操作（进行翻牌/累加总翻牌次数来计算答案）。两种操作在调用到某一节点的孩子时，均需向下传递 `lazy` 值（更新左、右孩子的真实翻牌次数）。

2. **问题**：区间的离散化处理

   **解决**：一开始叶节点的构造采用了排序、去重后的端点来构建，并没有考虑到应该存储的是区间而不是一个个孤立点。后面采用左闭右开来存储区间，并以最短区间单元为叶节点建树（而非以端点为叶节点建树）。

3. **复杂度估算**：

   1. **时间复杂度**：`O(mlogm)` 

      每次翻牌/查询操作若不涉及 `lazy` 值向下传递，则时间复杂度为 `O(logm)` ；若刚好需要向下传递 `lazy` 值，则时间复杂度为 `O(mlogm)` 。对于 `m` 个操作，因为应用了懒惰标记，因此总的平摊时间复杂度为 `O(mlogm)` 。

   2. **空间复杂度**： `O(m)` 

      待查询区间组成的节点个数为 `O(m)` ，所组成的最短区间单元为 `O(m)` ，其中建树所需节点为 `O(2^(logm))` 即 `O(m)` ，因此空间复杂度为 `O(m)` 。

